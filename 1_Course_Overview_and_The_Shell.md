(00:01) All right, everyone, thanks for coming in. This is the missing semester of your CS Education, at least that's what we chose to call the class. If you're not here for this class, then you're in the wrong room. We will be here for about an hour just to set your expectations, and I want to talk to you a little bit first about why we're doing this class.
(00:01) 大家好，感谢你们的参与。这门课程被称为“计算机科学教育中缺失的一课”，至少我们选择这么称呼这门课程。如果你们不是来上这门课的，那么你们来错地方了。我们会在这里待上大约一个小时，主要是为了设置一下大家的期望，我首先想和大家谈一下为什么我们要开设这门课。

(00:35) This class stems out of an observation that Anish and Jose and I have made while TA-ing various classes at MIT, which is that basically all of us computer scientists, we know that computers are great at doing these repetitive tasks and automating things. But we often fail to realize that there are lots of tools that can make our own development processes better. We can be a lot more efficient about how we use our computers because we can use the computer as a tool for ourselves, not just for building websites or software, those sorts of things.
(00:35) 这门课程是基于我们在麻省理工学院（MIT）协助教授多门课程期间所做的一项观察得出的。我们都是计算机科学家，我们知道**计算机非常擅长执行重复的任务和自动化处理**，但我们常常忽视了有很多工具可以使我们的开发过程变得更高效。我们可以更有效地使用计算机，将计算机作为工具，不仅用于构建网站或软件等等。

(01:08) And it's going to be a class where we want to teach you both how to make the most of the tools that you already know, but also hopefully teach you about some tools you don't know from before and how to combine those tools to produce more powerful things than you think you might be able to do with what you know today. The class is going to be structured as a series of 11 one-hour lectures, and each one is going to cover a particular topic. You can see the website, which is also listed there, for the list of lecture topics and what date.
这门课程旨在教会大家如何充分利用已经了解的工具，同时希望教会大家一些之前不了解的工具，以及如何将这些工具组合起来，以实现比你现在所知道的更强大的功能。这门课程将以一系列共11个一小时的讲座的形式组织，每个讲座将涵盖特定主题。你可以查看网站上列出的讲座主题和日期。

(01:43) We will do each one. They will mostly be independent, so you can sort of show up for the ones that you're interested in, but we will sort of assume that you've been following along, so that as we get to later lectures, I'm not going to be teaching you bash all over again, for example. We are also going to post both the lecture notes and recordings of the lectures online. Exactly when we do that, we haven't established yet, but it will be after the lectures. Obviously, the videos have to be posted after.
我们会逐一完成。它们大多是独立的，因此你可以选择你感兴趣的讲座，但我们会假定你一直在跟随讲座内容，所以当我们进入后面的讲座时，我不会再重新教授bash（一种Unix shell）等基础内容。我们还将在网上发布讲座笔记和录像，具体发布时间尚未确定，但会在讲座结束后发布。显然，视频必须在讲座结束后才能发布。

(02:14) The class is going to be run by me, John, and Anne, each sitting over there, and Jose, who is not currently here but will be holding tomorrow's lecture. And keep in mind that we're trying to cover a lot of ground over the course of just 11 one-hour lectures, and so we will be moving relatively rapidly. But please do stop us if there's anything where you feel like you're not following along, if you feel like there's something you wish we would spend more time on. Just let us know, please interrupt us with questions.
(02:14) 这门课程将由我、约翰、安妮以及明天将主持讲座的何塞共同进行。请记住，我们试图在仅有11个一小时讲座的课程中涵盖很多内容，所以我们将以相对快的速度进行教学。但是，如果有任何你觉得自己不理解的地方，或者希望我们花更多时间讲解的内容，请随时告诉我们，欢迎提问。

(02:42) And also, after each lecture, we're going to hold office hours on the ninth floor of building 30, the Stata Center of the computer science building. As if you show up on the ninth floor lounge there and the Gates Tower, then you can come and try some of the exercises that we give for each lecture or just ask us other questions about things we've talked about in the lecture or other things about using your computer efficiently. Due to the limited time that we have available, we're not going to be able to cover all tools in full detail.
(03:43) 此外，每节课后，我们将在麻省理工学院计算机科学大楼（Stata Center）的第九楼举行办公时间。如果你前往第九楼休息室和盖茨塔，你可以来尝试一些我们为每节课提供的练习，或者问我们有关讲座中讨论的内容或有关有效使用计算机的其他问题。由于时间有限，我们不会能够详细涵盖所有工具的内容，

(03:14) So what we'll try to do is highlight interesting tools and interesting ways to use them. We won't necessarily dig into the deep details about how all of it works or more elaborate use cases. But if you have questions about them, please come and ask us about that too. Many of these tools are tools that we have used for years, and we might be able to point you to additional interesting things you can do with them. Sort of like taking advantage of the fact that we're here. This class is going to, I don't want to say ramp up quickly, but what's going to happen over the course of this particular lecture is that we'll cover many of the basics that we assume that you will know for the rest of the semester. Things like how to use your shell and your terminal, and I'll explain what those are for those of you not familiar with them.
所以我们将尽量强调有趣的工具和有趣的使用方式。我们不一定会深入讨论所有工具的工作原理或更复杂的用例，但如果你对它们有疑问，请随时向我们提问。这些工具中的许多都是我们多年来一直在使用的工具，我们可能能够指导你如何利用它们做其他有趣的事情。毕竟，我们在这里，你可以充分利用我们的存在。我不想说这堂课会很快上完，但在这堂课中，我们会讲到许多基础知识，而这些基础知识我们假设你们在本学期剩下的时间里都会掌握。比如如何使用 shell 和终端，对于不熟悉的同学，我会向你们解释它们是什么。

(04:07) And then we'll pretty quickly ramp up into more advanced tools and how to use them. You can already see from the lecture notes the kind of topics that we're going to be covering.
然后，我们将很快进入更高级的工具以及如何使用它们。你已经可以从讲义中看到我们将要涉及的主题。

(04:37) And so that brings us to today's lecture in which we are going to cover the shell. And the shell is going to be one of the primary ways that you interact with your computer once you want to do more things than what the sort of visual interfaces you might be used to allow you to do. The visual interfaces are sort of limited in what they allow you to do because you can only do the things that there are buttons for, sliders for, input fields for. Often these textual tools are built to be both composable with one another but also to have tons of different ways to combine them or ways to program and automate them. And that is why in this class we will be focusing on these command line or text-based tools, and the shell is the place that you would do most of this work.
(04:37) 这就引出了今天的讲座，我们将讨论的主题是shell。一旦你想要做比你所熟悉的视觉界面所允许的更多的事情，shell将成为你与计算机交互的主要方式。视觉界面在允许你做的事情方面有一定的限制，因为你只能执行有按钮、滑块、输入字段的事情。通常，这些文本工具被设计为彼此可组合，同时有各种不同的组合方式或编程和自动化方式。这就是为什么在这门课程中，我们将专注于这些命令行或基于文本的工具，而shell将成为你主要进行这些工作的地方。

(05:08) So for those of you who are not familiar with the shell, most platforms provide some kind of shell. On Windows, this is often PowerShell, but there are also other shells available on Windows. On Linux, you will find tons of terminals, these are windows that allow you to display shells, and you'll also find many different types of shells, the most common of which is bash or the Bourne Again shell because it's such a common shell. It is the one we're primarily going to be covering in these lectures. If you're on macOS, you will probably also have bash, maybe an older version of it if you open the terminal app.
(05:08) 对于那些不熟悉shell的人，大多数平台都提供某种类型的shell。在Windows上，通常使用PowerShell，但也有其他可用的shell。在Linux上，你会找到很多终端窗口，用于显示shell，你也会找到许多不同类型的shell，其中最常见的是bash或Bourne-Again shell，因为它如此常见，所以我们将主要在这些讲座中进行介绍。如果你使用macOS，如果你打开终端应用程序，你可能也已经安装了bash，虽然可能是较旧的版本。

(05:34) So if you want to follow along on any of these platforms, feel free. But keep in mind that most of this is going to be sort of Linux-centric in terms of how we teach it, even though most of these tools work on all the platforms. If you want to install a terminal and a shell and you don't know how to do it, we're happy to show you at office hours. Or it's usually very easy to just Google your platform plus terminal, and you will get one.
(05:34) 所以，如果你想在任何这些平台上跟着进行学习，都可以。但请记住，尽管这些工具大多适用于所有平台，但我们的教学在很大程度上是以Linux为中心的。如果你想安装终端和shell，但不知道如何操作，我们将在办公时间向你展示。或者通常很容易只需搜索你的平台加上"终端"，你就会找到一个。

(06:10) Now, when you open a terminal, you get something that looks a little bit like this. So it will usually have just a single line at the top, and this is what's known as the shell prompt. You can see that my shell prompt looks like this. It has my username, the name of the machine that I'm on, the current path I'm on, and we will talk about paths a little bit later. And then it's really just sort of blinking there, asking me for input. This is the shell prompt where you tell the shell what you want it to do.
(06:10) 打开终端后，你会看到类似下面的界面。通常，界面顶部只有一行，这就是所谓的shell提示符。你可以看到我的shell提示符如下所示，它显示了我的用户名、我所在机器的名称、我当前的路径。我们稍后会详细讨论路径。然后，光标会不断闪烁，等待我的输入。这就是shell提示符，你可以在这里告诉shell你想让它执行什么操作。

(06:38) And you can customize this prompt a lot, and when you open it on your machine, it might not look exactly like this. It might look something like this if you've configured it a little, or it might look all sorts of different ways. We won't go too much into customizing your shell in this particular lecture. We'll do that later. Here we're just going to talk about how do you use this shell to do useful things. And this is our the main textual interface you have to your computer's through this shell.
(06:38) 你可以根据自己的需求自定义这个提示符，当你在自己的机器上打开终端时，它可能看起来与我的不太一样。你可以通过配置来更改它，也可以以各种不同的方式自定义。但在本讲座中，我们不会深入讨论如何自定义你的shell，这将在后面的讲座中进行。在这里，我们只会谈论如何使用这个shell来进行有用的操作。这是我们与计算机的主要文本界面。

(07:06) On the shell prompt, you get to write commands, and commands can be relatively straightforward things. Usually, it'll be something like executing programs with arguments. What does that look like? Well, one program we can execute is the date program. We just type "date" and press enter, and then it will show you, unsurprisingly, the date and time. You can also execute a program with arguments. This is one way to modify the behavior of the program.
(07:06) 在shell提示符上，你可以输入命令，命令可以是相对简单的操作。通常，这些命令是执行带有参数的程序，以修改程序的行为。具体是什么样的呢？首先，我们可以执行一个名为"date"的程序，只需输入"date"并按回车，然后它将显示日期和时间。你也可以使用参数来执行程序，这是修改程序行为的一种方式。

(07:37) So for example, there is a program called "echo," and "echo" just prints out the arguments that you give it. **And arguments are just whitespace-separated things that follow the program name**. So we can say "hello," and then it will print "hello" back. Perhaps not terribly surprising, but this is the very basics of arguments. One thing that you'll notice is that I said that arguments are separated by whitespace, and you might wonder, "Well, what if I want an argument as multiple words?"
(07:37) 例如，有一个名为"echo"的程序，它只会打印你提供的参数。参数只是程序名称之后的由空格分隔的内容。所以我们可以输入"hello"，然后它将打印"hello"。这可能并不令人惊讶，但这是关于参数的基础知识。你可能会注意到，我说参数是由空格分隔的，你可能会问，"如果我想要一个由多个单词组成的参数怎么办？"

(08:09) You can also quote things. So you can do things like "echo hello world," and now the echo program receives one argument that contains the string "hello world" with a space. Well, you can also use single quotes for this, and the difference between single quotes and double quotes we'll get back to when we talk about bash scripting. You can also just escape single characters, so for example, "hello world," this will also work just fine.
(08:09) 你也可以对参数进行引用。因此，你可以输入"echo hello world"，然后"echo"程序将接收一个包含字符串"hello world"及其之间有空格的参数。你还可以使用单引号进行引用，单引号和双引号之间的区别我们将在谈到bash脚本时回顾。你还可以对单个字符进行转义，例如，"hello world"，这也能正常工作。

(08:43) All of these rules about how you escape and how you parse and quote various arguments and variables we'll cover a little bit later. Hopefully, you won't run into too many gotchas about this. **Just keep in mind, at least, that spaces separate arguments**. So if you want to do something like make a directory called "my photos," you can't just type "make directory my photos," it will create two directories, one called "my" and one called "photos," and that is probably not what you want.
(08:43) 我们将稍后详细介绍如何转义、解析和引用各种参数和变量的规则。希望你不会遇到太多与此相关的麻烦。只要记住，至少空格是分隔参数的方式，所以如果你想要创建一个名为"my photos"的目录，你不能只输入"make directory my photos"，它将创建两个目录，一个叫"my"，一个叫"photos"，这可能不是你想要的。

(09:18) Now, one thing you might ask is, how does the shell know what these programs are when I type "date" or when I type "echo"? How does it know what these programs are supposed to do? And the answer to this is your computer has a bunch of built-in programs that come with the machine. Just like you, your machine might ship with the terminal app or it might ship with Windows Explorer or it might ship with some kind of browser. It also ships with a bunch of terminal-centric applications, and these are stored on your file system.
(09:18) 现在，你可能会问，当我输入"date"或"echo"时，shell是如何知道这些程序是什么，它们应该做什么的呢？答案是，你的计算机上有许多内置程序，随着机器提供。就像你的机器可能预装了终端应用程序，或者可能预装了Windows资源管理器，或者可能预装了某种浏览器一样。它也预装了许多终端相关的应用程序，这些应用程序存储在你的文件系统上。

(09:43) And your shell has a way to determine where a program is located, basically has a way to search for programs. It does this through something called an environment variable. An environment variable is a variable like you might be used to for programming languages. It turns out that the shell, and the Bourne-Again shell in particular, is really a programming language. This prompt that you're given here is not just able to run a program with arguments.
(09:43) 而你的shell有一种方法来确定程序的位置，基本上是通过一种叫做环境变量的方式来查找程序。环境变量就像你在编程语言中所熟悉的变量一样。事实证明，shell，特别是Bourne-Again shell，实际上是一种编程语言。这里给你的提示符不仅可以执行带参数的程序。

(10:10) You can also do things like while loops, for loops, conditionals. All of these, you can define functions, you can have variables, and all of these things you can do in the shell. We'll cover a lot of that in the next lecture, on shell scripting. For now, though, let's just look at this particular environment variable. Environment variables are things that are set whenever you start your shell. They're not things you have to set every time you run your shell.
(10:10) 你还可以执行诸如while循环、for循环、条件语句等操作。在这个提示符上，你可以定义函数，使用变量，所有这些东西你都可以在shell中做。我们将在下一讲座中详细介绍这些内容，那是关于shell脚本的内容。但现在，让我们只看看这个特定的环境变量。环境变量是在你启动shell时设置的东西。这不是你每次运行shell时都需要设置的东西。

(10:44) There are a bunch of these that are set, things like where is your home directory, what is your username, and there's also one that's critical for this particular purpose, which is the path variable. So if I echo out dollar path, this is going to show me all of the paths on my machine that the shell will search for programs. You'll notice that this is a list that is colon-separated. It might be kind of long and hard to read, but the essentials is that whenever you type the name of a program, it's going to search through this list of paths on your machine, and it's going to look in each directory for a program or a file whose name matches the command you try to run.
(10:44) 有很多这样的环境变量，比如你的主目录在哪里，你的用户名是什么，还有一个对于这个特定目的非常关键的变量，那就是PATH变量。如果我输出echo $PATH，它将显示出我机器上shell将搜索程序的所有路径。你会注意到这是一个以冒号分隔的列表。这可能会有点长，有点难读，但要点是，每当你输入一个程序的名称，它将遍历你机器上这个路径列表，按顺序查找每个目录中是否有包含你尝试运行的命令的程序或文件。

(11:16) So in my case, when I try to run "date" or "echo," it's going to walk through these one at a time until it finds one that contains the program called "date" or "echo," and then it's going to run it. If we want to know which one it actually runs, there's a command called "which," which lets us do that. So I can type "which echo," and it will tell me that if I were to run a program called "echo," I would run this one. It's worth pausing here to talk about what paths are. So paths are a way to name the location of a file on your computer. On Linux and Mac OS,
(11:16) 因此，在我的情况下，当我尝试运行"date"或"echo"时，它将逐个遍历这些目录，直到找到一个包含名为"date"或"echo"的程序的目录，然后它将运行它。如果我们想知道它实际运行的是哪个，有一个叫做"which"的命令可以帮助我们。所以，我可以输入"which echo"，它将告诉我，如果我要运行一个名为"echo"的程序，我将运行这个。值得在这里停下来讨论一下路径是什么。路径是一种用来表示文件在计算机上位置的方式，在Linux和Mac OS中。

(11:54) Everything lives under the root namespace, so all paths start with a slash. On Windows, all absolute paths have one root for every partition, like "C:\\" or "D:\\". Windows has separate file system path hierarchies for each drive. In contrast, on Linux and macOS, these are all mounted under one namespace.
(11:54) 一切都存在于根命名空间之下，因此所有路径都以斜杠开头。在Windows上，所有绝对路径都有一个根目录，每个分区都有一个，如 "C:" 或 "D:"。Windows为每个驱动器都有单独的文件系统路径层次结构。相比之下，在Linux和macOS上，它们都挂载在一个命名空间下。

(12:32) You'll notice that I mentioned the term "absolute path," and you might not be familiar with it. Absolute paths are paths that completely specify the location of a file. For example, this refers to a specific "echo" file and provides its full path. However, there are also relative paths. A relative path is based on your current location. To determine your current location, you can use the "PWD" command, which stands for "Present Working Directory." When I type "PWD," it displays the current path I'm in. Currently, I'm in the home directory under the root, then under John, and further under dev.
(12:32)你会注意到我提到了 "绝对路径" 这个术语，你可能不太熟悉。绝对路径是完全指定文件位置的路径。例如，这是指特定的 "echo" 文件并提供了其完整路径。然而，还有相对路径。相对路径是基于你当前的位置。要确定当前位置，你可以使用 "PWD" 命令，代表 "Present Working Directory"，当我键入 "PWD" 时，它会显示我当前所在的路径。目前，我在根目录下的家目录，然后是 John，进一步是 dev 目录。

(13:11) From here, you can choose to change your current working directory. All relative paths are relative to the current working directory. In this case, for example, I can use "CD /home" to change my current directory. As a result, my shell prompt reflects that I am now in the "home" directory. It shows only the last segment of the path. However, you can configure your terminal to display the full path wherever you are. If I type "PWD" again, it will indicate that I'm in "/home."
(13:11) 从这里，你可以选择更改当前的工作目录。所有相对路径都是相对于当前的工作目录。例如，在这种情况下，我可以使用 "CD /home" 来更改当前的目录。结果，我的Shell提示显示我现在位于 "home" 目录。它只显示路径的最后一个部分。但是，你可以配置终端以在任何地方显示完整路径。如果我再次键入 "PWD"，它将指示我在 "/home"。

(13:44) There are also a couple of special directories, namely ".", which represents the current directory, and "..," which signifies the parent directory. This is a convenient way to navigate through the system. For example, if I type "CD ..," it moves me to the root directory, represented as "/," from the previous location, which was "/home." If I type "PWD" now, it will display "/." You can also use relative paths to explore the file system. For instance, "CD ./home" will navigate to the "home" directory under the current location, bringing me back to "/home." If I try "CD ./home" again, it will return an error because there's no "home" directory under my current directory.
(13:44) 还有一些特殊的目录，即 "." 表示当前目录，".." 表示上一级目录。这是一个方便的导航方式。例如，如果我键入 "CD .."，它会将我移到根目录，表示为 "/"，从之前的位置，即 "/home"。如果我现在键入 "PWD"，它将显示 "/"。你还可以使用相对路径来浏览文件系统。例如，"CD ./home" 将导航到当前位置下的 "home" 目录，将我带回 "/home"。如果我尝试再次 "CD ./home"，它将返回一个错误，因为当前目录下没有 "home" 目录。


(14:22) You can traverse all the way back to the root using relative paths, such as "...." or ".....," which takes you to various locations in the file system. This brings you all the way back to the root directory, where you can find directories like "bin" and another "bin." For instance, there's an "echo" file under "bin," which you can execute using the "world" command. This is a method to construct paths for navigating your file system arbitrarily. You might choose either absolute or relative paths, typically favoring the shorter option.
(14:22) 你可以使用相对路径遍历回根目录，例如 "...." 或 "....."，将你带到文件系统中的不同位置。这将带你回到根目录，那里有像 "bin" 和另一个 "bin" 这样的目录。例如，在 "bin" 目录下有一个 "echo" 文件，你可以使用 "world" 命令来执行。这是构建任意浏览文件系统路径的一种方法。你可以选择绝对路径或相对路径，通常更倾向于更短的选项。

(15:30) If you wish to run a program or create one that runs other programs like "echo" or "date" from anywhere, you can either provide only the program's name, such as "date" or "echo," allowing the shell to locate it using the path, or provide its absolute path. Using a relative path may work for you in one directory but not for someone else in a different directory. Generally, when you run a program, it operates in the current working directory by default unless other arguments are specified. This is convenient because it often allows you to use just the file's name in the current directory.
(15:30) 如果你想要从任何地方运行程序或创建一个运行其他程序（如 "echo" 或 "date"）的程序，你可以选择仅提供程序的名称，如 "date" 或 "echo"，让Shell使用路径来定位它，或者提供其绝对路径。使用相对路径可能在一个目录中适用于你，但在另一个目录中不适用。一般来说，运行程序时，默认情况下它在当前工作目录中运行，除非指定了其他参数。这很方便，因为它通常只需要在当前目录中使用文件的名称。

(16:05) An essential command is to determine what's in the current directory. We've already seen "PWD," which displays your current location. There's also a command called "LS," which lists the files in the current directory. When I type "LS" here, it lists all the files in the current directory, providing a convenient way to navigate the file system quickly. If I change to a different directory and execute "LS," it shows the files in that directory. You can provide a path to "LS" as well. If I go all the way back to the root, you'll notice different files exist there.
(16:05) 一个重要的命令是确定当前目录中有什么。我们已经见过 "PWD"，它显示你的当前位置。还有一个命令叫做 "LS"，它列出当前目录中的文件。当我在这里键入 "LS" 时，它列出当前目录中的所有文件，提供了快速浏览文件系统的便捷方式。如果我切换到不同的目录并执行 "LS"，它将显示该目录中的文件。你还可以向 "LS" 提供路径。如果我回到根目录，你会注意到那里有不同的文件。

(17:45) Additionally, a tilde character "~" is a special symbol that takes you to your home directory, which always expands to your home directory. You can also use relative paths, such as "CD -," which takes you back to the directory you were previously in. Repeating "CD -" toggles between the last two directories you were in. With "LS" or "CD," there may be arguments and options you are not aware of. While we've mainly provided paths so far, most programs also accept arguments, flags, and options, typically starting with a hyphen ("-").
(17:45) 此外，波浪号 "~" 是一个特殊符号，它可以带你到你的家目录，始终展开到你的家目录。你还可以使用相对路径，比如 "CD -"，它可以将你带回到先前的目录。重复 "CD -" 可以在最近的两个目录之间切换。对于 "LS" 或 "CD"，可能存在你不熟悉的参数和选项。虽然到目前为止我们主要提供了路径，但大多数程序也接受参数、标志和选项，通常以连字符（"-"）开头。

(18:54) One common flag is "-help," implemented in most programs. If you run, for example, "LS -help," it will provide a wealth of information about the command. The usage line typically indicates that you can provide a varying number of options and files, with "..." meaning one or more and square brackets indicating optional items. You'll find details on what the program does and the various flags and options you can use. Usually, single-letter flags with a single hyphen are called "flags," and options are parameters that take a value, such as "-a" and "-all" for flags, and "-C" or "-color R" for options.
(18:54) 一个常见的标志是 "-help"，大多数程序都实现了它。例如，如果你运行 "LS -help"，它将提供关于该命令的大量信息。通常，使用线索的单字母标志和单连字符是 "标志"，而选项是带有值的参数，如 "-a" 和 "-all" 是标志，"-C" 或 "-color R" 是选项。

(19:37) One useful flag to look for is "-L," which enables the use of a long listing format. This format provides additional information about the files, as we'll see shortly. Towards the bottom of the manual page, you'll find examples, information about the program's author, and where to find more information. Exiting the manual page viewer can be confusing, but you can press "Q" to quit. Alternatively, a handy keyboard shortcut is "Ctrl + L," which clears your terminal and returns to the top.
(19:37) 一个有用的标志是 "-L"，它允许使用长格式列表。这个格式提供有关文件的额外信息，稍后我们将看到。在手册页面的底部，你会找到示例、有关程序作者的信息以及更多信息的获取位置。退出手册页面查看器可能会令人困惑，但你可以按 "Q" 退出。另一个方便的键盘快捷键是 "Ctrl + L"，它清除终端并返回到顶部。

(26:25) You should be aware that for removing, especially on Linux, the removal is not recursive by default. To remove a directory, you should use the -r flag for a recursive remove. If you want to remove an empty directory, you can use the "RM dr" command. This is a safety mechanism to prevent accidentally deleting directories with content. "Mkdir" is another handy command that lets you create a new directory. Make sure to handle spaces in directory names properly, either by escaping the space or using quotes. If you want more information about how specific commands work on your system, you can use the "man" command followed by the program name to access its manual pages. The "man" command provides in-depth documentation and examples for various programs. 
(26:25) 你应该知道，在Linux上，删除操作默认情况下不是递归的。要删除目录，你应该使用 -r 标志进行递归删除。如果你想删除一个空目录，你可以使用 "RM dr" 命令。这是一个安全机制，以防止意外删除带有内容的目录。"Mkdir" 是另一个有用的命令，它允许你创建一个新目录。确保正确处理目录名称中的空格，可以通过转义空格或使用引号。如果你想了解关于系统上特定命令的工作方式的更多信息，你可以使用 "man" 命令，后跟程序名称以访问其手册页面。"man" 命令提供各种程序的深入文档和示例。

(28:08) So far, we've discussed individual programs. However, the real power of the shell comes when you start combining different programs. Instead of just running "CD," "LS," etc., you might want to chain multiple programs together, enabling them to interact with files that pass between them. You can achieve this using the concept of streams. Every program, by default, has two primary streams: an input stream and an output stream. The input stream is typically your keyboard or terminal, and anything you type becomes input to the program.
(28:08) 到目前为止，我们已经讨论了单个程序。但是，Shell 的真正威力在于当你开始组合不同的程序时。你可以将多个程序链接在一起，使它们能够相互交互并传递文件。你可以使用流的概念来实现这一点。默认情况下，每个程序都有两个主要流：输入流和输出流。输入流通常是你的键盘或终端，你键入的任何内容都成为程序的输入。

(28:39) And it has a default output stream, which is whenever the program prints something, it's gonna print to that stream. And by default, that is also your terminal. This is why when I type "echo hello," it gets printed back to my terminal. But the shell gives you a way to rewire these streams to change where the input output of a programmer pointed. The most straightforward way you do this is using the angle bracket signs. So you can write something like this, or you can write something like this. The left angle bracket indicates rewire the input for this program to be the contents of this file, and the end angle bracket means rewire the output of the preceding program into this file.
(28:39) 这段文字讲述了终端具有默认的输出流，通常情况下，程序输出会打印到该流，而默认情况下，这也是你的终端。这就是为什么当你键入“echo hello”时，它会回显到终端上。但是，shell提供了一种方式来重新定向这些流，以更改程序的输入和输出指向的位置。最常见的方式是使用尖括号符号。你可以像这样写，或者像这样写。左尖括号表示将此程序的输入重新定向为此文件的内容，右尖括号表示将前面程序的输出重新定向到此文件。

(29:14) So let's look at an example of what that would look like. If I do "echo hello," I can say I want that context, the content to be stored in a file called "hello.txt." And because I gave this is a relative path, this will construct a file in the current directory called "hello.txt," and at least in theory, its contents should be the word hello. So if I run this, notice that nothing got printed to my output. The previous time when I ran "echo hello," it printed hello. Now that hello is going gone into a file called "hello.txt."
(29:14) 现在，让我们看一个示例。如果我执行“echo hello”，然后告诉系统将其内容存储在一个名为“hello.txt”的文件中，因为我使用的是相对路径，这将在当前目录创建一个名为“hello.txt”的文件，理论上，它的内容应该是单词“hello”。因此，如果我运行这个命令，注意到没有任何内容被打印到我的输出上。之前我运行“echo hello”时，它会打印出hello。现在，hello已经存储在名为“hello.txt”的文件中。

(29:50) And I can verify this by using the program called "cat." So "cat" prints the contents of a file. So I can do "cat hello.txt," and there it shows me hello. But "cat" is also something that supports this kind of wiring. So I can say "cat," which by default just prints its input; it just duplicates its input to its output. I can say I want you to take your input from "Hello text." What will happen in this case is that the shell is going to open "hello.txt," take its contents and set that to be the input of "cat," and then "cat" is going to just print that to its output, which since I haven't rewired it is gonna be my terminal.
(29:50) 我可以使用一个名为“cat”的程序来验证这一点。所以“cat”用于打印文件的内容。因此，我可以执行“cat hello.txt”，它将显示出“hello”。但是，“cat”也支持这种重定向。因此，我可以告诉“cat”默认情况下只是将其输入复制到输出。我可以告诉它使用“hello.txt”作为输入。在这种情况下，shell将打开“hello.txt”，获取其内容并将其设置为“cat”的输入，然后“cat”将其打印到输出，因为我没有重新定向输出，所以它将打印到我的终端。

(30:25) This will just print hello to the output. And I can use both of these at the same time. So for example, if I want to copy a file, and I don't want to use the "CP command" for some reason, I can do this. And in this case, I'm telling the "cat" program nothing at all. I'm just saying do your normal thing, right? The "cat" program does not know anything about this redirection. But I'm telling the shell to use "hello.txt" as the input for "cat" and to write anything that "cat" prints - hello - dot txt. Again, this prints nothing to my terminal, but if I "cat hello.txt," I get the output as I would have expected, which is a copy of the original file.
(30:25) 这将只会打印出“hello”。我还可以同时使用这两种方式。例如，如果我想复制一个文件，但由于某种原因不想使用“cp”命令，我可以这样做。在这种情况下，我告诉“cat”程序什么也不要做。我只是说按照你的正常方式运行，对吗？“cat”程序对于这种重定向一无所知。但是我告诉shell使用“hello.txt”作为“cat”的输入，并将“cat”打印的任何内容写入“hello.txt”。同样，这不会在我的终端上打印任何内容，但如果我执行“cat hello.txt”，我将获得预期的输出，即原始文件的副本。


(30:57) There is also a double end bracket which is append instead of just overwrite. So you'll notice that I, if I do "cat hello.txt - hello.txt" again and then I "cat hello2.txt," it still just contains hello even though it already contained hello. If I switch that to instead be a double end bracket, it means append. And if I now "cat" that file, it has a hello twice.
(30:57) 还有一个双尖括号，它表示追加而不是覆盖。你会注意到，如果我再次执行“cat hello.txt > hello.txt”，然后执行“cat hello2.txt”，它仍然只包含一个“hello”，尽管它已经包含一个“hello”。如果我将其更改为双尖括号，表示追加，如果我现在执行“cat”该文件，它会包含两个“hello”。

(31:32) These are pretty straightforward. They're usually just ways to interact with files. But where it gets really interesting is an additional operator the shell gives you called the pipe character. So pipe is just a vertical bar. And what pipe means is take the output of the program to the left and make it the input of the program to the right, right.
(31:32) 这些都很简单，通常只是与文件交互的方式。但当引入终端提供的另一个运算符——管道符（pipe）时，情况变得非常有趣。管道符只是一条竖线。管道符表示将左侧程序的输出作为右侧程序的输入。

(32:05) So what does this look like? Well, let's take the example of "ls /" or "ls -l /." This prints a bunch of things. Let's say that I only wanted the last line of this output. Well, there's a command called "tail," and "tail" prints the last n lines of its input, and I can do -n1. So this is a flag called "n"; you can also use "dash-dash lines" if you want to use it as a longer option. But in this case, this is saying just print the last line, and I can wire these together, so I can say "ls -l / | tail -n1,"
(32:05) 简单来说，就是将左侧程序的输出作为右侧程序的输入。这是一个示例：“ls /”或“ls -l /”。这会打印很多信息。假设我只想要这些输出的最后一行。有一个名为“tail”的命令，它会打印其输入的最后n行，我可以使用“-n1”。所以这是一个名为“n”的标志，你也可以使用“-lines”来作为更长的选项。在这种情况下，它表示只打印最后一行，然后我们可以将它们链接在一起，即“ls -l / | tail -n1”。

(32:47) And notice here that "ls" does not know about "tail," and "tail" does not know about "ls." They are different programs and have never been programmed to be compatible with one another. All they know how to do is read from input and write to output. And then the pipe is what wires them together. And in this particular case, I'm saying I want the output of "ls" to be the input to "tail." And then I want the output of "tail" to just go to my terminal because I haven't rewired it. I could also rewire this to say I want the output to go to "ls.txt,"
(32:47) 请注意，"ls"不知道"tail"，"tail"也不知道"ls"。它们是不同的程序，从未被编程为彼此兼容。它们只知道如何从输入中读取数据并写入输出，而管道将它们连接在一起。在这种特定情况下，我告诉系统我想要将"ls"的输出作为"tail"的输入，并我希望"tail"的输出直接显示在我的终端上，因为我没有重新定向它。我也可以重新定向它，比如将输出重定向到"ls.txt"。

And in this (33:17) case, if I cat ls.text, I would get the appropriate output. And it turns out you can do some really neat things with this. We're gonna cover this a lot more in the data wrangling lecture that will be in like four days or something on the kind of fancy stuff you can do when you start building more advanced pipelines.
(33:17) 在这种情况下，如果我使用“cat ls.text”，我将获得相应的输出。事实上，你可以做一些非常有趣的事情。我们将在后面的数据处理讲座中更详细地讨论这个话题，以及当你开始构建更高级的管道时可以做的一些高级操作。

To give you one example, we can do something like curl --head --silent google.com. (33:42) So just to show you what that looks like, this gives me all the HTTP headers for accessing google.com, and I can pipe that to grep -i, so -i if I want content length. So this is gonna print the content length header. Grep is a program that we'll talk about later that'll let you search in an input stream for a given keyword.
举一个例子，我们可以执行像这样的操作："curl --head --silent google.com"。这会给我返回访问google.com的所有HTTP标头，然后我可以使用管道符“|”将其传递给“grep -i”，这里的“-i”表示不区分大小写，所以这会打印内容长度（Content-Length）标头。"grep"是一个稍后将讨论 的程序，它允许你在输入流中搜索指定的关键词。

We can pipe that through, say, the cut command which takes a delimiter, set that to be space, and I want the second field. And this prints just the content length. This is sort of (34:24) a silly example, right? Like this just lets you extract the content length in bytes of google.com from the command line. It's not a very useful thing to do, but you can see how by chaining these together you can achieve a bunch of really interesting text manipulation effects.
接着，我们可以将其通过“cut”命令传递，该命令使用分隔符（在这里是空格）来划分文本，并提取我们需要的信息，例如，我们可以提取Content-Length字段，这将打印出内容长度。这可能看起来有点傻，因为我们只是从命令行中提取了Google.com的字节长度，但你可以看到通过链式操作，我们可以实现许多有趣的文本操作效果。

And it turns out pipes are not just for textual data. You can do this for things like images as well. You can have a program that manipulates a binary image on its input and writes a binary image to its output, and you can chain them together in this way. And we'll talk (34:53) about some of those kinds of examples later on. You can even do this for video if you want. You can stream, this is for example, a great way if you have a Chromecast at home, you can stream a video file like this by having the last program in your pipe be a Chromecast send program. So you stream a video file into it and it streams over HTTP to your Chromecast.
这并不仅仅适用于文本数据。你也可以将其应用于图像等二进制数据。你可以有一个处理二进制图像的程序，将其输入和输出连接在一起，就像我们刚才所做的。稍后我们将讨论一些更高级的例子，甚至可以用于视频。如果你拥有家里的Chromecast设备，你可以使用这种方式通过将最后一个程序设置为Chromecast发送程序，来流式传输视频文件。这样，你可以将视频文件流式传输到Chromecast。

We'll take, we'll talk a lot more about this in the data wrangling lecture, but there's one more thing that I wanted to talk to you about, about sort of (35:25) how to use the terminal in a more interesting and perhaps more powerful way that you might be used to. And this is perhaps even going to be interesting for the ones of you who feel like you're already comfortable with the terminal.
在未来的数据处理讲座中，我们将更详细地讨论这些内容，以及当你开始构建更高级管道时可以做的一些有趣的事情。还有一件事情我想告诉你，关于如何更有趣、更强大地使用终端，甚至对那些已经熟悉终端的人来说，这也可能是有趣的
But first we need to cover an important topic when it comes to Linux systems and Mac OS systems in particular, which is the notion of the root user. The root user is sort of like the administrator user on Windows and has user ID zero. The root user is special because it is allowed to do whatever it wants on your (35:57) system, even if a file is like not readable by anyone or if it's not writable by anyone. Root can still access that file.
首先，我们需要介绍关于Linux系统和Mac OS系统的一个重要概念，即"root"用户。"root"用户类似于Windows上的管理员用户，其用户ID为零。"root"用户特殊之处在于它可以在系统上执行任何操作，即使某个文件对任何人都不可读或不可写，"root"用户仍然可以访问该文件。

Root is sort of a super user that gets to do whatever they want, and most of the time you will not be operating as the super user. You will not be root. You will be a user like John or whatever your name is, and that's going to be the user you act with, because if you were operating your computer as the root user at all times, if you ran the wrong program, they could just completely destroy your computer and you don't want (36:27) that, right?
"root"用户是一个超级用户，可以为所欲为，但大部分时间你不会以"root"用户的身份运行。你将作为像John或其他用户名的普通用户进行操作，因为如果你一直以"root"用户身份操作计算机，如果运行错误的程序，可能会导致计算机被毁坏，这是不希望发生的。

But every now and again you want to do something that requires that you are root, usually for these cases you will use a program called sudo. Sudo, do as super user and su in this case is super user. So this is a way to do the following thing as the super user, usually the way sudo works is you write sudo and then a command like you would normally on your terminal, and it will just run that command as if you were root as opposed to the user you actually are. Where might you need something like this?
然而，有时你需要以"root"用户的身份执行某些操作，通常这些情况下，你将使用一个名为"sudo"的程序。"sudo"代表"以超级用户身份执行"，而"su"中的"su"代表"super user"。这是以超级用户身份执行以下操作的一种方式。通常，"sudo"的工作方式是你输入"sudo"，然后是命令，就像你在终端上通常执行命令一样，它将以超级用户的身份运行该命令，而不是你实际的用户身份。那么，你可能会问在什么情况下需要以超级用户身份执行某些操作？

Well, there is a special, there are (37:05) many special file systems on your computer, but in particular there's one called sysfs. If you CD to slash sys, this is a whole new world. This file system is not actually files on your computer. Instead these are various kernel parameters. So the kernel is like basically the the core of your computer. This is a way for you to access various kernel parameters through what looks like a file system.
好，有一个特殊的文件系统，你的计算机上有很多特殊的文件系统，其中之一就是"sysfs"。如果你切换到"/sys"目录，你将进入一个全新的世界。这个文件系统实际上不是你计算机上的文件，而是各种内核参数。因此，内核实际上是计算机的核心。这是一个通过看起来像文件系统的方式来访问各种内核参数的方法。

You'll see here that if I CD into class for example, it has directories for a bunch of different types of devices that I can interact (37:40) with, or various queues I can access, or all sorts of weird knobs internally. And because they're exposed as files, it means we can also use all the tools we've been using so far in order to manipulate them.
你会看到，如果我进入"class"目录，它有各种不同类型的设备目录，你可以与之交互，或者各种内部的奇怪参数。因为它们被展示为文件，这意味着我们也可以使用我们到目前为止学到的工具来操作它们。

One example of this is if you go into sys class backlight, so this backlight directory lets you configure the backlight on your laptop if you have one. So I can CD in to intel backlight. This is an Intel laptop inside.
这是一个示例，如果你进入/sys/class/backlight目录，这个backlight目录允许你配置笔记本电脑的背光，如果你有一台笔记本电脑的话。所以我可以cd进入intel backlight目录。这是一台Intel笔记本电脑。


Here you'll see there's a file called brightness and I can cat the brightness. (38:13) This is the current brightness of my screen, but not only that, I can modify this too in order to change the brightness of my screen. So you might think that I could do, let's see what the max brightness is here. Okay, so it's currently set to the max brightness. You might imagine that I could do something like, if I do echo let's do half or something, echo 500 to brightness. If I do this, it says permission denied. I'm not allowed to modify brightness because in order to basically, in order to change things in the kernel you need to be the (38:47) administrator.
在这里，你会看到有一个名为brightness的文件，我可以cat brightness。这是我的屏幕的当前亮度，但不仅如此，我也可以修改它以改变屏幕的亮度。所以你可能会认为我可以做一些像，让我们看看这里的最大亮度是多少。好的，它当前设置为最大亮度。你可以想象我可以做一些像，如果我执行`echo`，让我们设置为一半，`echo 500 > brightness`。如果我这样做，它会显示"权限被拒绝"。我无权修改亮度，因为要改变内核中的东西，你需要成为管理员。

And you might imagine that the way to solve this is to write sudo echo 500, but I still get a permission denied error. But why is that? It's because as I mentioned before, these redirections of input and output is not something the programs know about. When we piped LS to tail, tail did not know about LS and LS did not know about tail. The pipe and the redirection was set up by the shell. So in this case, what's happening is I'm telling my shell, run the program sudo with the arguments echo and 500 and send its output to the (39:21) file called brightness. But the shell is what is opening the brightness file. It is not the sudo program.
你可能会想，解决这个问题的方法是使用`sudo echo 500`，但我仍然会得到一个"权限被拒绝"的错误。但为什么呢？这是因为如我之前提到的，程序不知道输入和输出的重定向是由shell设置的。当我们将LS重定向到tail时，tail不知道LS，而LS也不知道tail。管道和重定向是由shell设置的。所以在这种情况下，实际上是我在告诉我的shell运行`sudo`程序，带有`echo`和`500`这两个参数，并将其输出发送到名为`brightness`的文件。但是打开`brightness`文件的是shell，而不是`sudo`程序。

So in this case, the shell which is running as me tries to open the brightness file for writing and it's not allowed to do that. And therefore I get a permission denied error. You might have seen this if you, like, search for something, end up on Stack Overflow, and it tells you just run this command and you'll see that it does something like they give you instructions like, run this as root. This is something that is very rarely explained but that is what the pound symbol means. You'll see on my prompt there's a dollar symbol instead and the dollar indicates you are not running as root.
因此，在这种情况下，作为我的shell的程序尝试以写入的方式打开`brightness`文件，但它无权这样做，因此我得到了"权限被拒绝"的错误。你可能会在搜索某些内容，然后进入Stack Overflow并看到一些指令，就像告诉你运行这个命令一样，然后你会发现它做了一些操作，类似这种指令非常少被解释，但这就是井号（#）的含义。你可以看到我的提示符上有一个美元符号，而不是井号，美元符号表示你不是以root用户身份运行的。

So the question is, how do I get around this? Well, I could switch into a root terminal. So one way to do this is to run sudo su. Sudo su is saying run the following (40:27) command as root, and su is a complicated command that effectively gets you a shell as the super user. So if I do this, type my password, then now you'll see that the username at the beginning changed from Jon to root, and the prompt changed from a dollar to a pound. If I now run that command, if I do echo 500 to brightness, my screen got a little dimmer, but you can't see it. You just have to trust me. And now I didn't get an error and this is because the shell is now running as root. It is not running as (41:02) Jon and the root user is allowed to open this file.
那么问题是，如何解决这个问题呢？好吧，我可以切换到root终端。一种方法是运行`sudo su`。`sudo su`表示以root身份运行以下命令，`su`是一个复杂的命令，它实际上会为你提供超级用户的shell。所以如果我这样做，输入我的密码，那么现在你会看到用户名从Jon变成了root，提示符从美元符号变成了井号。如果我现在运行那个命令，如果我执行`echo 500 > brightness`，我的屏幕变暗了一点，但你看不到。你只能相信我。现在我没有收到错误，因为shell现在以root身份运行，而不是Jon，而root用户有权打开这个文件。

But given our knowledge that we have of the terminal now, there's actually a way for us to do this without having to drop to a root shell and run commands there, which can often be somewhat dangerous. And that is as follows. Let's restore it to 1060. Do you see why this is different here? I'm telling my shell to run the echo 1060 command, which is gonna echo 1060, and I'm telling it to run the sudo tee brightness command, and I'm telling tee to send the output of echo into sudo tee in order to understand this (41:39) you need to know what the tee command does.
但根据我们现在对终端的了解，实际上有一种方法可以在不必降级到root shell并在那里运行命令的情况下执行此操作，这通常可能有一定的风险。方法如下，恢复它为1060。你能看出这里有什么不同吗？我在告诉我的shell运行`echo 1060`命令，这个命令将会输出1060，然后我告诉它运行`sudo tee brightness`命令，并告诉`tee`将`echo`的输出发送到`sudo tee`，要理解这一点，你需要知道`tee`命令是做什么的。

The tee command takes its input and writes it to a file but also to standard out. So tee is a convenient way if you have, say, a log file that you want to like send to a file to store for later but you also want to see it to yourself, then you can pipe it through tee, give it the name of a file, and it will write whatever its input is both to that file and to your screen. And here I'm taking advantage of that program. I'm saying run tee as root and have tee write into the brightness (42:10) file. And so in this case, the tee program, which is what is opening the brightness file, is running as root. And so it is allowed to do it.
`tee`命令接受输入并将其写入文件以及标准输出。所以`tee`是一个方便的方式，如果你有一个日志文件，你想将其发送到一个文件以供以后使用，但你也想自己看到它，那么你可以通过`tee`将其通过管道传递给`tee`，指定一个文件名，它将将其输入写入该文件以及你的屏幕。在这里，我利用了这个程序。我告诉它以root权限运行，并让`tee`将输出写入`brightness`文件。所以在这种情况下，打开`brightness`文件的程序是`tee`，它以root身份运行，所以它有权这样做。

If I run this, it will now again, you can't see, but the brightness on my laptop has been turned on. And I don't get any errors. And I never had to drop into a root shell and run commands there, which can often be somewhat dangerous. If you want to explore this file system a little bit more, there's a lot of interesting stuff in here if you just sort of start browsing around. You can (42:39) find all sorts of fun things.
如果我运行这个命令，现在，你看不到，但是我的笔记本屏幕的亮度已经调低了。我没有收到任何错误，并且我从未降级到root shell并在那里运行命令，这通常可能有一定的风险。如果你想进一步探索这个文件系统，如果你开始浏览，你会发现很多有趣的东西。

So for example, we noticed that there was this fun brightness command here. I wonder what other kinds of brightness I can set. So I can use the find command, which we will also talk about in a coming lecture. I want to look for any file whose name contains brightness in the current directory. That's unhelpful. Maybe they're not files. Did I misspell brightness? Yeah, why is it being annoying? Oh, apparently it does not want to search for brightness for me. How well, luckily (43:20) for you I know of one already. Handy that there is a subdirectory called LEDs, and LEDs have brightness too. What kind of LEDs are there? Ooh, lots of things, for example, the scroll lock LED.
所以，例如，我们注意到这里有一个有趣的`brightness`命令。我想知道还有哪些亮度可以设置。所以我可以使用`find`命令，我们将在即将的讲座中也讨论。我要查找当前目录中名称包含`brightness`的任何文件。这不太有帮助。也许它们不是文件。我拼错了"brightness"吗？是的，为什么它如此烦人？哦，显然它不想为我搜索"brightness"。无论如何，幸运的是，我已经知道一个了。幸好有一个名为"LEDs"的子目录，而LEDs也有亮度。有什么样的LED？哦，有很多东西，例如滚动锁定LED。

Now most of you probably don't know what the scroll lock LED is, or much less what scroll lock is. You might have seen a key on your keyboard labeled scroll lock. Basically no one knows what it means anymore. No one really uses it for anything. It's mostly just a dead key and also a dead LED. What if you wanted to configure it so that every time you get (43:57) email, your scroll lock LED lights up because there's no other reason why it would light up? Well, if we CD into this particular directory that has a brightness place, and it's set to zero, well, what happens if I write one into it?
现在，你大多数人可能不知道滚动锁定LED是什么，更不用说什么是滚动锁定了。你可能在键盘上看到一个标有"Scroll Lock"的键。基本上没人知道它的意义了。没有人真的用它来做任何事情。它基本上是一个无用的键和一个无用的LED。但如果你想配置它，使得每当你收到电子邮件时，滚动锁定LED会亮起，因为除了这个原因，它不会亮起，那该怎么办呢？如果我们进入了这个具有亮度位置的特定目录，它设置为零，那么如果我写入1，会发生什么呢？

You probably should not just be writing random numbers into random files in this directory because you are affecting your kernel directly. Like, look up what the files do in this particular case. I have worn safety goggles, and I've done my research. So now you can't tell, but on my (44:28) keyboard, the scroll lock LED is now lit. So now if I wrote a program that like did some checking of mail and stuff, I could have it at the end run a program that echoes one into this file. And now I have a way for my LED on my keyboard to indicate when I have new email.
通常情况下，你不应该只是将随机数字写入这个目录中的随机文件，因为你直接影响到内核。在这种特定情况下，我已经采取了安全措施，并做了研究。所以现在你看不到，但是在我的键盘上，滚动锁定LED现在亮起了。所以现在，如果我编写一个程序来检查邮件等等，我可以在最后运行一个程序，将1写入这个文件。现在，我的键盘LED可以指示我是否有新的电子邮件。

At this point, you should know roughly your way around the terminal, around the shell, and know enough to accomplish these basic tasks at least in theory. Now you shouldn't need to use like point and click interfaces to find files anymore. There's one remaining trick you might (45:05) need, and that is the ability to open a file. So far I've only really given you ways to find files, but one thing you should know about is "missing semester xdg-open". This will probably only work on Linux. On Mac OS I think it's just called open. On Windows, who knows.
到了这一点，你应该大致了解如何使用终端，如何使用shell，并且至少在理论上了解足够的基本任务。现在，你不应该再需要使用点和点击界面来查找文件了。还有一个剩下的技巧，你可能会需要，那就是打开文件。到目前为止，我只是教给你如何找到文件，但你应该知道关于"missing semester xdg-open"。这可能只在Linux上有效。在Mac OS上，我认为它只被称为"open"。在Windows上，谁知道呢。

xdg-open, you give the name of a file, and it will open it in the appropriate program. So if you open, if you do xdg-open an HTML file, that will open your browser and open that file. And once you have that program, in theory you should no longer need to open like a Finder window (45:43) ever again. You might want to for other reasons, but in theory you can accomplish it all using the tools that we've learned today.
对于xdg-open，你提供文件的名称，它会在适当的程序中打开它。所以如果你用xdg-open打开一个HTML文件，它将打开你的浏览器并打开那个文件。一旦你掌握了这个程序，在理论上，你将不再需要打开Finder窗口了。你可能出于其他原因想要打开，但在理论上，你可以使用今天学到的工具来完成所有这些任务。

This might all seem relatively basic for some of you, but as I mentioned, this is sort of the ramp up period of now we all know how the shell works, and a lot of what we'll be doing in future lectures is using this knowledge to do really interesting things using the shell that sort of this is learning the the interface that we're going to be using. And so it's important (46:11) we all know it.
这对于你们中的一些人来说可能都显得相对基础，但正如我之前提到的，现在我们都知道shell的工作方式，我们将在未来的讲座中使用这些知识来做一些非常有趣的事情，使用shell来实现。这是学习我们将要使用的接口，因此这是非常重要的。

We're gonna talk a lot more in the next lecture about how to automate tasks like this, how to write scripts that run a bunch of programs for you and have to do things like conditionals and loops and stuff in your terminal, and do things like run a program until it fails, which can be handy in classes where you want to run something until your test suite fails for example. So that's the topic for next week's lecture.
在下一讲中，我们将更多地讨论如何自动化类似这样的任务，如何编写脚本来运行一系列程序，并要在终端中执行条件语句和循环等操作，以及如何运行一个程序，直到它失败为止，这在你想运行某些测试套件直到失败的情况下可能会很有用。这是下周讲座的主题。

Did you have a question? It's like what you've been demoing this sys directory that presumably will (46:42) only work if you're running... That is a good question. I don't know whether the Windows Subsystem for Linux will expose the sys file system. If it does, it probably only exposes a very small number of things. It might, because there are... I don't know, check it out.
你有问题吗？就像你一直在演示这个sys目录，可能只适用于正在运行... 这是一个很好的问题。我不知道Windows Subsystem for Linux是否会公开sys文件系统。如果它这样做，可能只公开了很少一部分东西。也许会，因为有...我不知道，可以去查一下。

One thing you'll see is the lecture notes for this lecture are already online, and at the very bottom of the file there are a bunch of exercises, some of them are relatively easy, some of them are a little bit harder. And what we encourage you to do is to take a stab at (47:23) going through them.f you don't, it might teach you a bunch of things that you might not realize you didn't know. And for the office hours that we're gonna do right after this lecture, we will happily help you get through all of those, or if there are other commands and things you learn in the process you want to know how to use more efficiently.
你会看到这个讲座的讲座笔记已经在线上，文件的底部有一些练习题，其中一些相对容易，一些可能有点难。我们鼓励你尝试做这些练习。如果你不做，它可能会教给你一些你可能没有意识到的东西。在我们将在本讲座后不久举行的办公时间里，我们将乐意帮助你完成所有这些练习，或者如果在过程中学到其他命令和技巧，你想要更高效地使用它们，我们也会帮助你。

And then in next lecture, which is tomorrow, we will basically be assuming that you know the kind of stuff that the exercises are going to teach you. (47:48) There's also an email address on the website where you can send us questions if you think of something like after the office hours are finished.
然后在下一讲，也就是明天，我们将基本上假定你已经掌握了这些练习将教给你的知识。在办公时间结束后，如果你有任何问题，网站上有一个电子邮件地址，你可以发送问题给我们。

Are there any questions before we end today? No, no? Alright, well we will have office hours on the ninth floor of the Gates building, building 32, in like five minutes. Sweet, see you there!
今天结束之前还有问题吗？没有问题吗？好吧，我们将在Gates大楼的九楼，即32号楼的九楼举行办公时间，大约五分钟后见。好的，到时候见！